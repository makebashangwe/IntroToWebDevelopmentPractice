<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel = "stylesheet" href = "styles.css">
    <title>HTTP3</title>

</head>
<header>
    <nav>
        <ul>
            <li><a href="index.html"><h3>Home</h3></a></li>
            <li><a href="key-concepts.html"><h3>Key Concepts</h3></a></li>
            <li><a href="early-http.html"><h3>Early HTTP</h3></a></li>
            <li><a href="http2.html"><h3>HTTP2</h3></a></li>
            <li><a href="http3.html"><h3>HTTP3</h3></a></li>
            <li><a href="apis-cloud.html"><h3>Api & Cloud</h3></a></li>
            <li><a href="security-https.html"><h3>Security</h3></a></li>
            <li><a href="about.html"><h3>About</h3></a></li>

        </ul>
                    <h1 class="header-logo">HTTP</h1>

    </nav>

    <h1 class="header-title">HTTP 3 +  QUIC</h1>
</header>

<body>
    <main class="container">
    <section aria-labelledby="intro">
        <h2 id="intro">Intro</h2>
        <p>
        HTTP/3 runs over <strong>QUIC</strong>, a transport protocol that uses UDP instead of TCP.
        QUIC was designed to keep the good parts of HTTP/2 (like multiplexing) while fixing
        transport-layer head-of-line blocking and speeding up connection setup with built-in security.
        </p>
    </section>

    <section aria-labelledby="independent-streams">
        <h2 id="independent-streams">Independent Streams (Fixing TCP Head-of-Line Blocking)</h2>
        <p>
        In TCP, all data in a connection shares one ordered byte stream. If one packet is lost,
        later data must wait—even if it belongs to a different resource. This is called
        <em>head-of-line (HoL) blocking</em>.
        </p>
        <p>
        QUIC uses <strong>multiplexed, independent streams</strong> within a single connection.
        Packet loss on one stream does not stall others. Practically, that means a dropped video
        segment does not freeze your chat messages, and a slow image download does not block your CSS.
        </p>
        <ul>
        <li>One connection &rarr; many logical streams.</li>
        <li>Per-stream flow control and loss recovery.</li>
        <li>Fewer stalls and more predictable latency under loss.</li>
        </ul>
    </section>

    <section aria-labelledby="tls13">
        <h2 id="tls13">TLS 1.3 Integrated Into Transport</h2>
        <p>
        QUIC <strong>integrates TLS 1.3</strong> directly into the transport handshake. Unlike TCP+TLS,
        there is no separate negotiation layer; encryption and transport parameters are established together.
        </p>
        <ul>
        <li><strong>Always encrypted</strong>: even the first application bytes are protected.</li>
        <li><strong>Modern ciphers only</strong>: forward secrecy and faster handshakes by default.</li>
        <li><strong>Simpler stack</strong>: fewer transitions between protocol layers.</li>
        </ul>
    </section>

    <section aria-labelledby="fewer-steps">
        <h2 id="fewer-steps">Fewer Steps to Establish a Connection</h2>
        <p>
        With TCP, a new secure connection typically needs a 3-way handshake plus a TLS handshake.
        QUIC combines these into <strong>one handshake</strong>, and can even use
        <strong>0-RTT</strong> to send early data to known servers.
        </p>
        <h3>Typical Handshake Comparison</h3>
        <ol>
        <li><strong>TCP+TLS:</strong> TCP handshake (SYN, SYN-ACK, ACK) &rarr; TLS 1.3 handshake &rarr; HTTP request.</li>
        <li><strong>QUIC:</strong> QUIC+TLS 1.3 handshake (combined) &rarr; HTTP/3 request.</li>
        </ol>
        <p>
        Result: faster first byte and better page start under both clean and lossy networks.
        </p>
    </section>

    <section aria-labelledby="benefits">
        <h2 id="benefits">Real-World Benefits</h2>
        <ul>
        <li><strong>Smoother streaming:</strong> Audio/video segments arrive on dedicated streams that are not blocked by other assets.</li>
        <li><strong>Faster page loads:</strong> Multiplexing plus quicker handshakes reduce time to first render.</li>
        <li><strong>Better real-time apps:</strong> Chats, gaming, and calls see fewer stalls when some packets drop.</li>
        <li><strong>Connection migration:</strong> QUIC uses stable connection IDs, allowing a connection to survive IP/Network changes (e.g., Wi-Fi to cellular) without reconnecting.</li>
        <li><strong>Smarter congestion control:</strong> Modern loss recovery and pacing tailored to UDP-based transport.</li>
        </ul>
    </section>

    <section aria-labelledby="how-it-works">
        <h2 id="how-it-works">How HTTP/3 Over QUIC Works (At a Glance)</h2>
        <ol>
        <li>Client sends an Initial QUIC packet containing TLS 1.3 ClientHello.</li>
        <li>Server replies with TLS 1.3 ServerHello and transport parameters; keys are established.</li>
        <li>Streams are opened for requests (headers via QPACK) and responses (body frames, etc.).</li>
        <li>Loss recovery and congestion control run per connection; blocking is isolated per stream.</li>
        <li>If the client’s IP changes, the connection continues using the same Connection ID.</li>
        </ol>
        <p>
        Note: HTTP/3 replaces HTTP/2’s HPACK with <strong>QPACK</strong>, which is designed for independent streams so header compression doesn’t reintroduce HoL blocking.
        </p>
    </section>

    <section aria-labelledby="when-to-use">
        <h2 id="when-to-use">When It Helps Most</h2>
        <ul>
        <li>Mobile users switching networks or moving between cells.</li>
        <li>Lossy Wi-Fi or crowded public hotspots.</li>
        <li>Media-heavy pages with many parallel resources.</li>
        <li>Live/interactive apps where jitter and stalls are noticeable.</li>
        </ul>
    </section>

    <section aria-labelledby="dev-notes">
        <h2 id="dev-notes">Developer Notes</h2>
        <ul>
        <li>Servers and CDNs must support QUIC and HTTP/3.</li>
        <li>Clients (browsers, SDKs) negotiate HTTP/3 via Alt-Svc or direct support.</li>
        <li>Firewalls and load balancers should allow UDP on the chosen QUIC ports (commonly 443/UDP).</li>
        <li>Measure with real-user monitoring: look at TLS handshake time, TTFB, and stall rates under loss.</li>
        </ul>
    </section>

    <section aria-labelledby="faq">
        <h2 id="faq">Quick FAQ</h2>
        <h3>Is TCP obsolete now?</h3>
        <p>No. TCP remains widely used. QUIC is a strong fit for web traffic and real-time apps, but many systems still rely on TCP.</p>

        <h3>Does QUIC guarantee lower bandwidth?</h3>
        <p>No. QUIC improves latency and resilience to loss. Throughput depends on network capacity and server/client tuning.</p>

        <h3>Can I mix HTTP/2 and HTTP/3?</h3>
        <p>Yes. Most deployments keep HTTP/2 as a fallback. Clients will negotiate the best available protocol.</p>
    </section>

    <section aria-labelledby="summary">
        <h2 id="summary">Summary</h2>
        <ul>
        <li>Independent streams eliminate TCP’s transport-level HoL blocking.</li>
        <li>TLS 1.3 is built into QUIC for secure, faster handshakes.</li>
        <li>Fewer round trips reduce connection setup time.</li>
        <li>Great for streaming, faster page loads, and real-time applications.</li>
        </ul>
    </section>
    </main>

</body>
<footer>This is a class project for IT 3203. Course site: https://ksuweb.github.io/IT3203/</footer>
<footer class="footer-logo"><a href = "https://www.linkedin.com/in/makebashangwe/">@makebashangwe</a></footer>
</html>